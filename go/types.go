// Code generated by schema-generate. DO NOT EDIT.

package main

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
)

// LogEntryActor
type LogEntryActor struct {
	Identity *LogEntryIdentity `json:"identity"`
	Name     string            `json:"name"`

	// A Sym Resource Name (SRN) is a unique identifier for a Sym Resource.
	User     string `json:"user"`
	Username string `json:"username,omitempty"`
}

// LogEntryApprovalFields This object will also contain all of the user-supplied fields.
type LogEntryApprovalFields struct {
	AdditionalProperties map[string]interface{} `json:"-,omitempty"`
	Duration             int                    `json:"duration"`
	Reason               string                 `json:"reason"`
	Target               *LogEntryTarget        `json:"target"`
}

// LogEntryError
type LogEntryError struct {

	// A machine-consumable error code.
	Code string `json:"code,omitempty"`

	// A human-consumable error message.
	Message string `json:"message,omitempty"`
}

// LogEntryEvent
type LogEntryEvent struct {
	Channel string `json:"channel"`

	// A Sym Resource Name (SRN) is a unique identifier for a Sym Resource.
	Srn string `json:"srn"`

	// A Sym Resource Name (SRN) is a unique identifier for a Sym Resource.
	Template  string `json:"template"`
	Timestamp string `json:"timestamp"`
	Type      string `json:"type"`
}

// LogEntryFields This object will also contain all of the user-supplied fields.
type LogEntryFields struct {
	AdditionalProperties map[string]interface{} `json:"-,omitempty"`
}

// LogEntryIdentity This object will also contain any fields contained in the specific Identity (e.g. the User ID of a Slack User).
type LogEntryIdentity struct {
	AdditionalProperties map[string]interface{} `json:"-,omitempty"`
	ExternalId           string                 `json:"external_id"`
	Service              string                 `json:"service"`
}

// LogEntryMeta
type LogEntryMeta struct {
	SchemaVersion int `json:"schema_version,omitempty"`
}

// LogEntryRun
type LogEntryRun struct {

	// A Sym Resource Name (SRN) is a unique identifier for a Sym Resource.
	Flow string `json:"flow"`

	// A Sym Resource Name (SRN) is a unique identifier for a Sym Resource.
	Parent string `json:"parent,omitempty"`

	// A Sym Resource Name (SRN) is a unique identifier for a Sym Resource.
	Srn string `json:"srn"`
}

// LogEntryTarget
type LogEntryTarget struct {
	Label    string            `json:"label"`
	Name     string            `json:"name"`
	Settings map[string]string `json:"settings"`

	// A Sym Resource Name (SRN) is a unique identifier for a Sym Resource.
	Srn  string `json:"srn"`
	Type string `json:"type"`
}

// State
type State struct {
	Errors []*LogEntryError `json:"errors"`
	Status string           `json:"status"`
}

// SymLogEntry This model is sent by Sym both to Log Destinations for [reporting](https://docs.symops.com/docs/reporting), as well as for the [HTTP](https://docs.symops.com/docs/http) and [AWS Lambda](https://docs.symops.com/docs/aws-lambda) Strategies.
type SymLogEntry struct {
	Actor  *LogEntryActor `json:"actor"`
	Event  *LogEntryEvent `json:"event"`
	Fields interface{}    `json:"fields"`

	// A UUID which is guaranteed to be consistent for duplicate records.
	Id    string        `json:"id"`
	Meta  *LogEntryMeta `json:"meta"`
	Run   *LogEntryRun  `json:"run"`
	State *State        `json:"state"`
	Type  string        `json:"type"`
}

func (strct *LogEntryActor) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// "Identity" field is required
	if strct.Identity == nil {
		return nil, errors.New("identity is a required field")
	}
	// Marshal the "identity" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"identity\": ")
	if tmp, err := json.Marshal(strct.Identity); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Name" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "name" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "User" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "user" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"user\": ")
	if tmp, err := json.Marshal(strct.User); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "username" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"username\": ")
	if tmp, err := json.Marshal(strct.Username); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *LogEntryActor) UnmarshalJSON(b []byte) error {
	identityReceived := false
	nameReceived := false
	userReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "identity":
			if err := json.Unmarshal([]byte(v), &strct.Identity); err != nil {
				return err
			}
			identityReceived = true
		case "name":
			if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
				return err
			}
			nameReceived = true
		case "user":
			if err := json.Unmarshal([]byte(v), &strct.User); err != nil {
				return err
			}
			userReceived = true
		case "username":
			if err := json.Unmarshal([]byte(v), &strct.Username); err != nil {
				return err
			}
		}
	}
	// check if identity (a required property) was received
	if !identityReceived {
		return errors.New("\"identity\" is required but was not present")
	}
	// check if name (a required property) was received
	if !nameReceived {
		return errors.New("\"name\" is required but was not present")
	}
	// check if user (a required property) was received
	if !userReceived {
		return errors.New("\"user\" is required but was not present")
	}
	return nil
}

func (strct *LogEntryApprovalFields) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// "Duration" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "duration" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"duration\": ")
	if tmp, err := json.Marshal(strct.Duration); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Reason" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "reason" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"reason\": ")
	if tmp, err := json.Marshal(strct.Reason); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Target" field is required
	if strct.Target == nil {
		return nil, errors.New("target is a required field")
	}
	// Marshal the "target" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"target\": ")
	if tmp, err := json.Marshal(strct.Target); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal any additional Properties
	for k, v := range strct.AdditionalProperties {
		if comma {
			buf.WriteString(",")
		}
		buf.WriteString(fmt.Sprintf("\"%s\":", k))
		if tmp, err := json.Marshal(v); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
		comma = true
	}

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *LogEntryApprovalFields) UnmarshalJSON(b []byte) error {
	durationReceived := false
	reasonReceived := false
	targetReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "duration":
			if err := json.Unmarshal([]byte(v), &strct.Duration); err != nil {
				return err
			}
			durationReceived = true
		case "reason":
			if err := json.Unmarshal([]byte(v), &strct.Reason); err != nil {
				return err
			}
			reasonReceived = true
		case "target":
			if err := json.Unmarshal([]byte(v), &strct.Target); err != nil {
				return err
			}
			targetReceived = true
		default:
			// an additional "interface{}" value
			var additionalValue interface{}
			if err := json.Unmarshal([]byte(v), &additionalValue); err != nil {
				return err // invalid additionalProperty
			}
			if strct.AdditionalProperties == nil {
				strct.AdditionalProperties = make(map[string]interface{}, 0)
			}
			strct.AdditionalProperties[k] = additionalValue
		}
	}
	// check if duration (a required property) was received
	if !durationReceived {
		return errors.New("\"duration\" is required but was not present")
	}
	// check if reason (a required property) was received
	if !reasonReceived {
		return errors.New("\"reason\" is required but was not present")
	}
	// check if target (a required property) was received
	if !targetReceived {
		return errors.New("\"target\" is required but was not present")
	}
	return nil
}

func (strct *LogEntryEvent) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// "Channel" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "channel" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"channel\": ")
	if tmp, err := json.Marshal(strct.Channel); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Srn" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "srn" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"srn\": ")
	if tmp, err := json.Marshal(strct.Srn); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Template" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "template" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"template\": ")
	if tmp, err := json.Marshal(strct.Template); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Timestamp" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "timestamp" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"timestamp\": ")
	if tmp, err := json.Marshal(strct.Timestamp); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Type" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "type" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *LogEntryEvent) UnmarshalJSON(b []byte) error {
	channelReceived := false
	srnReceived := false
	templateReceived := false
	timestampReceived := false
	typeReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "channel":
			if err := json.Unmarshal([]byte(v), &strct.Channel); err != nil {
				return err
			}
			channelReceived = true
		case "srn":
			if err := json.Unmarshal([]byte(v), &strct.Srn); err != nil {
				return err
			}
			srnReceived = true
		case "template":
			if err := json.Unmarshal([]byte(v), &strct.Template); err != nil {
				return err
			}
			templateReceived = true
		case "timestamp":
			if err := json.Unmarshal([]byte(v), &strct.Timestamp); err != nil {
				return err
			}
			timestampReceived = true
		case "type":
			if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
				return err
			}
			typeReceived = true
		}
	}
	// check if channel (a required property) was received
	if !channelReceived {
		return errors.New("\"channel\" is required but was not present")
	}
	// check if srn (a required property) was received
	if !srnReceived {
		return errors.New("\"srn\" is required but was not present")
	}
	// check if template (a required property) was received
	if !templateReceived {
		return errors.New("\"template\" is required but was not present")
	}
	// check if timestamp (a required property) was received
	if !timestampReceived {
		return errors.New("\"timestamp\" is required but was not present")
	}
	// check if type (a required property) was received
	if !typeReceived {
		return errors.New("\"type\" is required but was not present")
	}
	return nil
}

func (strct *LogEntryFields) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal any additional Properties
	for k, v := range strct.AdditionalProperties {
		if comma {
			buf.WriteString(",")
		}
		buf.WriteString(fmt.Sprintf("\"%s\":", k))
		if tmp, err := json.Marshal(v); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
		comma = true
	}

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *LogEntryFields) UnmarshalJSON(b []byte) error {
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		default:
			// an additional "interface{}" value
			var additionalValue interface{}
			if err := json.Unmarshal([]byte(v), &additionalValue); err != nil {
				return err // invalid additionalProperty
			}
			if strct.AdditionalProperties == nil {
				strct.AdditionalProperties = make(map[string]interface{}, 0)
			}
			strct.AdditionalProperties[k] = additionalValue
		}
	}
	return nil
}

func (strct *LogEntryIdentity) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// "ExternalId" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "external_id" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"external_id\": ")
	if tmp, err := json.Marshal(strct.ExternalId); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Service" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "service" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"service\": ")
	if tmp, err := json.Marshal(strct.Service); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal any additional Properties
	for k, v := range strct.AdditionalProperties {
		if comma {
			buf.WriteString(",")
		}
		buf.WriteString(fmt.Sprintf("\"%s\":", k))
		if tmp, err := json.Marshal(v); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
		comma = true
	}

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *LogEntryIdentity) UnmarshalJSON(b []byte) error {
	external_idReceived := false
	serviceReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "external_id":
			if err := json.Unmarshal([]byte(v), &strct.ExternalId); err != nil {
				return err
			}
			external_idReceived = true
		case "service":
			if err := json.Unmarshal([]byte(v), &strct.Service); err != nil {
				return err
			}
			serviceReceived = true
		default:
			// an additional "interface{}" value
			var additionalValue interface{}
			if err := json.Unmarshal([]byte(v), &additionalValue); err != nil {
				return err // invalid additionalProperty
			}
			if strct.AdditionalProperties == nil {
				strct.AdditionalProperties = make(map[string]interface{}, 0)
			}
			strct.AdditionalProperties[k] = additionalValue
		}
	}
	// check if external_id (a required property) was received
	if !external_idReceived {
		return errors.New("\"external_id\" is required but was not present")
	}
	// check if service (a required property) was received
	if !serviceReceived {
		return errors.New("\"service\" is required but was not present")
	}
	return nil
}

func (strct *LogEntryRun) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// "Flow" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "flow" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"flow\": ")
	if tmp, err := json.Marshal(strct.Flow); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "parent" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"parent\": ")
	if tmp, err := json.Marshal(strct.Parent); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Srn" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "srn" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"srn\": ")
	if tmp, err := json.Marshal(strct.Srn); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *LogEntryRun) UnmarshalJSON(b []byte) error {
	flowReceived := false
	srnReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "flow":
			if err := json.Unmarshal([]byte(v), &strct.Flow); err != nil {
				return err
			}
			flowReceived = true
		case "parent":
			if err := json.Unmarshal([]byte(v), &strct.Parent); err != nil {
				return err
			}
		case "srn":
			if err := json.Unmarshal([]byte(v), &strct.Srn); err != nil {
				return err
			}
			srnReceived = true
		}
	}
	// check if flow (a required property) was received
	if !flowReceived {
		return errors.New("\"flow\" is required but was not present")
	}
	// check if srn (a required property) was received
	if !srnReceived {
		return errors.New("\"srn\" is required but was not present")
	}
	return nil
}

func (strct *LogEntryTarget) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// "Label" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "label" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"label\": ")
	if tmp, err := json.Marshal(strct.Label); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Name" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "name" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Settings" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "settings" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"settings\": ")
	if tmp, err := json.Marshal(strct.Settings); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Srn" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "srn" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"srn\": ")
	if tmp, err := json.Marshal(strct.Srn); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Type" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "type" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *LogEntryTarget) UnmarshalJSON(b []byte) error {
	labelReceived := false
	nameReceived := false
	settingsReceived := false
	srnReceived := false
	typeReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "label":
			if err := json.Unmarshal([]byte(v), &strct.Label); err != nil {
				return err
			}
			labelReceived = true
		case "name":
			if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
				return err
			}
			nameReceived = true
		case "settings":
			if err := json.Unmarshal([]byte(v), &strct.Settings); err != nil {
				return err
			}
			settingsReceived = true
		case "srn":
			if err := json.Unmarshal([]byte(v), &strct.Srn); err != nil {
				return err
			}
			srnReceived = true
		case "type":
			if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
				return err
			}
			typeReceived = true
		}
	}
	// check if label (a required property) was received
	if !labelReceived {
		return errors.New("\"label\" is required but was not present")
	}
	// check if name (a required property) was received
	if !nameReceived {
		return errors.New("\"name\" is required but was not present")
	}
	// check if settings (a required property) was received
	if !settingsReceived {
		return errors.New("\"settings\" is required but was not present")
	}
	// check if srn (a required property) was received
	if !srnReceived {
		return errors.New("\"srn\" is required but was not present")
	}
	// check if type (a required property) was received
	if !typeReceived {
		return errors.New("\"type\" is required but was not present")
	}
	return nil
}

func (strct *State) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// "Errors" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "errors" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"errors\": ")
	if tmp, err := json.Marshal(strct.Errors); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Status" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "status" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"status\": ")
	if tmp, err := json.Marshal(strct.Status); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *State) UnmarshalJSON(b []byte) error {
	errorsReceived := false
	statusReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "errors":
			if err := json.Unmarshal([]byte(v), &strct.Errors); err != nil {
				return err
			}
			errorsReceived = true
		case "status":
			if err := json.Unmarshal([]byte(v), &strct.Status); err != nil {
				return err
			}
			statusReceived = true
		}
	}
	// check if errors (a required property) was received
	if !errorsReceived {
		return errors.New("\"errors\" is required but was not present")
	}
	// check if status (a required property) was received
	if !statusReceived {
		return errors.New("\"status\" is required but was not present")
	}
	return nil
}

func (strct *SymLogEntry) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// "Actor" field is required
	if strct.Actor == nil {
		return nil, errors.New("actor is a required field")
	}
	// Marshal the "actor" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"actor\": ")
	if tmp, err := json.Marshal(strct.Actor); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Event" field is required
	if strct.Event == nil {
		return nil, errors.New("event is a required field")
	}
	// Marshal the "event" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"event\": ")
	if tmp, err := json.Marshal(strct.Event); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Fields" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "fields" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"fields\": ")
	if tmp, err := json.Marshal(strct.Fields); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Id" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "id" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"id\": ")
	if tmp, err := json.Marshal(strct.Id); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Meta" field is required
	if strct.Meta == nil {
		return nil, errors.New("meta is a required field")
	}
	// Marshal the "meta" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"meta\": ")
	if tmp, err := json.Marshal(strct.Meta); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Run" field is required
	if strct.Run == nil {
		return nil, errors.New("run is a required field")
	}
	// Marshal the "run" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"run\": ")
	if tmp, err := json.Marshal(strct.Run); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "State" field is required
	if strct.State == nil {
		return nil, errors.New("state is a required field")
	}
	// Marshal the "state" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"state\": ")
	if tmp, err := json.Marshal(strct.State); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Type" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "type" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SymLogEntry) UnmarshalJSON(b []byte) error {
	actorReceived := false
	eventReceived := false
	fieldsReceived := false
	idReceived := false
	metaReceived := false
	runReceived := false
	stateReceived := false
	typeReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "actor":
			if err := json.Unmarshal([]byte(v), &strct.Actor); err != nil {
				return err
			}
			actorReceived = true
		case "event":
			if err := json.Unmarshal([]byte(v), &strct.Event); err != nil {
				return err
			}
			eventReceived = true
		case "fields":
			if err := json.Unmarshal([]byte(v), &strct.Fields); err != nil {
				return err
			}
			fieldsReceived = true
		case "id":
			if err := json.Unmarshal([]byte(v), &strct.Id); err != nil {
				return err
			}
			idReceived = true
		case "meta":
			if err := json.Unmarshal([]byte(v), &strct.Meta); err != nil {
				return err
			}
			metaReceived = true
		case "run":
			if err := json.Unmarshal([]byte(v), &strct.Run); err != nil {
				return err
			}
			runReceived = true
		case "state":
			if err := json.Unmarshal([]byte(v), &strct.State); err != nil {
				return err
			}
			stateReceived = true
		case "type":
			if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
				return err
			}
			typeReceived = true
		}
	}
	// check if actor (a required property) was received
	if !actorReceived {
		return errors.New("\"actor\" is required but was not present")
	}
	// check if event (a required property) was received
	if !eventReceived {
		return errors.New("\"event\" is required but was not present")
	}
	// check if fields (a required property) was received
	if !fieldsReceived {
		return errors.New("\"fields\" is required but was not present")
	}
	// check if id (a required property) was received
	if !idReceived {
		return errors.New("\"id\" is required but was not present")
	}
	// check if meta (a required property) was received
	if !metaReceived {
		return errors.New("\"meta\" is required but was not present")
	}
	// check if run (a required property) was received
	if !runReceived {
		return errors.New("\"run\" is required but was not present")
	}
	// check if state (a required property) was received
	if !stateReceived {
		return errors.New("\"state\" is required but was not present")
	}
	// check if type (a required property) was received
	if !typeReceived {
		return errors.New("\"type\" is required but was not present")
	}
	return nil
}
